---
title: Printing From Flex Dashboard
author: Harrison Schramm and Aaron Berg
date: '2017-06-28'
categories: 
- R Language
- RStudio
- Shiny
tags: 
- R
- Shiny
- Flexdashboard
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Shiny applications of all stripes (including [flexdashboard with runtime Shiny](http://rmarkdown.rstudio.com/flexdashboard/shiny.html)) are revolutionary in that they put the power of R directly in the end user's hands without needing to interact directly with the language.  A common way end-users wish to interact with their data is via a dashboard that they can manipulate on the fly.  [Flexdashboard](http://rmarkdown.rstudio.com/flexdashboard/) streamlines the process of turning an R-based analysis into a dashboard, so R users can create good-looking output for their analyses - and deploy this output to the web - with very little additional effort.

There are various ways to extract information from flexdashboard, but no good way to programatically return a printable version of the *dashboard itself*.  This is partially by design - responsive HTML dashboards aren't meant to be printed.  There are [well-documented workflows](https://shiny.rstudio.com/articles/generating-reports.html) about how to share information between a web-centric output and a complementary report that renders to a printable format.  

That said, there are some reasons to want a printable output that looks similar to a related HTML report.  Snapshots are valuable for documentation/training materials, for embedding in emails or other reports, or for the all-too-common case of meetings with executives who like dashboards but want to consume paper-based reports.  Plus, flexdashboards are an incredibly quick way to create visually appealing *(read: pretty)* summary output of a combination of outputs on a single page.

Both Harrison and Aaron[^about] have struggled with trying to print flexdashboards in their respective practices.  In a recent instance, Harrison was working with a client whose end users would be carrying snapshots of the dashboard into an industrial setting where mobile devices were not desired.  It was important to the client to maintain a similar look between the on-screen and paper representations of the dashboard.  It was also important to make generating these snapshots an integrated part of the application; it was not sufficient to suggest that the client manually take a screenshot of their browser window.  This turned out to be a blessing, because (as you will see below) it allows the creation of a web-friendly 'tabbed' report with a companion 'flat' printed rendering.  

[^about]: [Harrison Schramm](https://www.linkedin.com/in/harrisonschramm) is an Operations Research Analyst at [CANA Advisors](http://www.canallc.com/).  [Aaron Berg](https://www.linkedin.com/in/aaron-berg-26150917/) is a Customer Success Representative at RStudio.

###Specific Task

Our goal was to create a "printable" flexdashboard with runtime Shiny.  Flexdashboard produces a beautiful HTML dashboard with very little effort.  [Like all R Markdown documents](https://shiny.rstudio.com/articles/interactive-docs.html), it also allows [Shiny](https://shiny.rstudio.com/) objects to be embedded inside of it, so that when rendered locally or on a server, it produces a reactive web application with minimal developer effort.  Like many HTML files, however, it does not print well.

The flexdashboard in question also had tabsets, which make perfect sense on a computer or mobile device, but don't translate well to printed media.  When printed, tabsets communicate that there is pertinent information hidden from the viewer; better to remove the tabset in the printed version.  If the information is pertinent, it should be displayed in the printed document; if it is not, it should be removed.

###PhantomJS and Headless Chrome

The approach we settled on as *good enough and easy enough* was to use a [headless browser](https://en.wikipedia.org/wiki/Headless_browser) to take a screenshot of a non-reactive HTML document.  It's not a perfect solution: a PDF would be better than a png file, headless browsers add a code dependency, and there is some administrative overhead to create the document to print.  It is, however, quick to implement, easy to understand, and robust.

###Example[^download]

[^download]: To recreate this minimal example for yourself, please download the files from [this gist](https://gist.github.com/agberg/d71d3aacb9b9d5691b7ba7ab7555ba5b).

The mechanics of building a screen-capture-style report from flexdashboard are neither difficult nor obvious.  In general, it requires the following steps:

1.  Add a downloadButton to a [flexdashboard with runtime Shiny](http://rmarkdown.rstudio.com/flexdashboard/shiny.html)
2.  When the download button is invoked, temporarily save non-reactive copies of any objects of interest
3.  Knit a static HTML version of the flexdashboard, using the objects saved in the prior step
4.  Use [```webshot::webshot```](https://github.com/wch/webshot) or [```decapitated::chrome_shot```](https://github.com/hrbrmstr/decapitated) to capture a .png image of the static dashboard[^1]
5.  Deliver this version to the client using the downloadHandler function

[^1]: The [```webshot```](https://github.com/wch/webshot) package requires phantomJS to be installed as an external dependency, but will work on all systems.  [```decapitated```](https://github.com/hrbrmstr/decapitated) will only work on systems with versions of Chrome that can operate in [headless mode](https://developers.google.com/web/updates/2017/04/headless-chrome).

The solution requires two separate R documents.  The process is as follows:

#### Dynamic Flexdashboard document

<pre><code>
---
title: "Snapshot Example"
runtime: shiny
output:
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: scroll
---
</code></pre>

This is standard YAML header for a flexdashboard, including the command ```runtime: shiny``` to create a Shiny application from an R Markdown document.  Let's examine the next chunks:

`r ''````{r}
gears = mtcars$gear %>% as.factor() %>% levels()
selectizeInput("grs", "GEARS",
               gears, selected = gears[1])
renderUI({
downloadButton("downloadFile", "Download")
})
`r ''````

In this chunk, we have built a ```selectizeInput``` object to choose the number of gears to select, as well as a ```downloadButton``` named 'downloadFile'.  Notice that we have wrapped the button in a ```renderUI()``` context. This is standard shiny / flexdashboard code.  

`r ''````{r}
mpgp = reactive({
  mtcars %>% filter(gear %in% input$grs) %>% ggplot(aes(x = hp, y = mpg)) + geom_point() + geom_smooth()
  
})
renderPlot({
  mpgp()
})

`r ''````

For veteran shiny programmers, this block may seem redundant.  We're creating a plot called ```mpgp``` in a reactive context and then rendering it.  In a 'standard' shiny implementation, we would simply have wrapped the plot code in the ```renderPlot()``` context.  However, as you will see below, we're going to need to reuse the object ```mpgp```.  

`r ''````{r}
output$downloadFile <- downloadHandler(filename = function() { 
return(paste('Cars', '.png', sep=''))
},
    content = function(file){
    to_save <- list(
    mpgg = mpgg(),
    mpgp = mpgp()
    )
      saveRDS(to_save, "config_data.RDS")
      rmarkdown::render("ShadowCars.Rmd")
      webshot::webshot("ShadowCars.html", file = file)
                        })
`r ''````

This chunk contains the secret sauce.  When the ```downloadButton``` is invoked, the program saves all elements to appear in the downloaded report in a file called 'config_data.RDS'.  These elements are then used as arguments to render a shadow document, 'ShadowCars.Rmd'.  Finally, ```webshot::webshot``` converts the hidden document to a .png and delivers it to the client side.

The full dashboard looks like this:

<!-- ![*Screenshot of our minimal implementation of a flexdashboard with downloadable screenshot*](/post/2017-06-19-Printing-From-Flex-Dashboard_files/MinDWN.png) -->

![](/post/2017-06-19-Printing-From-Flex-Dashboard_files/MinDWN.png)

#### Shadow Document

The key elements of the shadow document code are presented below:

```
---
title: "Snapshot Example"
output:
  flexdashboard::flex_dashboard:
    orientation: rows
---
```

Note that our YAML for the shadow document is similar to the dashboard, except it does **not** include ```runtime: shiny```

The code blocks that render the objects created in the dynamic document are straightforward to the point of triviality; they simply reference the saved objects (which are retrieved using ```readRDS```) and render them using whatever we choose, in this case ```kable()``` for the table and the native `print()` for the plot.    

`r ''````{r}
data <- readRDS("config_data.RDS")
data$mpgg %>% kable() 
`r ''````

`r ''````{r}
data$mpgp %>% print() 
`r ''````

And of course, while ```mpgp``` was reactive in the original dashboard, it is static in the shadow doc.  

The report delivered to the client is as follows:

<!-- ![*Example of the type of report delivered to the client in png format.  Note that while the report contains the same objects as the dynamic page, the chart and graph are laid side-by-side, not tabset*](/post/2017-06-19-Printing-From-Flex-Dashboard_files/Cars.png) -->

![](/post/2017-06-19-Printing-From-Flex-Dashboard_files/Cars.png)

##Conclusion

In this short post, we have shown how to create a downloadable custom report by using existing tools to create a static flexdashboard.  From the .png environment, the rendered image can be converted to other formats as required.
