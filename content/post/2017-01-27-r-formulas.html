---
author: "Max Kuhn"
categories: []
date: 2017-01-27T14:19:41-08:00
draft: true
summary: ""
tags: [R, Formulas]
title: "The R Formula Method: The Good Parts"
---

<!-- BLOGDOWN-HEAD -->
<!-- /BLOGDOWN-HEAD -->

<!-- BLOGDOWN-BODY-BEFORE -->
<!-- /BLOGDOWN-BODY-BEFORE -->
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>The formula interface to symbolically specify blocks of data is ubiquitous in R. It is commonly used to generate <em>design matrices</em> for modeling function (e.g. <code>lm</code>). In traditional linear model statistics, the <em>design matrix</em> is the two-dimensional representation of the predictor set where instances of data are in rows and variable attributes are in columns (a.k.a. the <em>X</em> matrix).</p>
<p>A simple motivating example uses the inescapable iris data in a linear regression model:</p>
<pre class="r"><code>mod1 &lt;- lm(Sepal.Width ~ Petal.Width + log(Petal.Length) + Species, 
           data = iris, subset = Sepal.Length &gt; 4.6)</code></pre>
<p>While the purpose of this code chunk is to fit a linear regression models, the formula is used to specify the symbolic model as well as generating the intended design matrix. Note that the formula method defines the columns to be included in the design matrix, as well as which rows should be retained.</p>
<p>Formulas are used in R beyond specifying statistical models, and their use has been growing over time (see <a href="https://cran.r-project.org/web/packages/lazyeval/vignettes/lazyeval.html">this</a> or <a href="http://rmhogervorst.nl/cleancode/blog/2016/06/13/NSE_standard_evaluation_dplyr.html">this</a>).</p>
<p>In this post, I’ll walk through the mechanics of how some modeling functions use formulas to make a design matrix using <code>lm</code> to illustrate the details. Note, however, that the syntactical minutiae are likely to be different from function to function, even within base R.</p>
</div>
<div id="formulas-and-terms" class="section level2">
<h2>Formulas and Terms</h2>
<p><code>lm</code> initially uses the formula and the appropriate environment to translate the relationships between variables to creating a data frame containing the data. R has a fairly <a href="https://stat.ethz.ch/R-manual/R-devel/library/stats/html/formula.html">standard set of operators</a> that can be used to create a matrix of predictors for models.</p>
<p>We will start by looking at some of the internals of <code>lm</code> (circa December 2016).</p>
<div id="preparing-for-the-model-frame" class="section level3">
<h3>Preparing for the Model Frame</h3>
<p>The main tools used to get the design matrix are the <code>model.frame</code> and <code>model.matrix</code> functions. The definition and first few lines of <code>lm</code> are:</p>
<pre class="r"><code>function (formula, data, subset, weights, na.action, method = &quot;qr&quot;, 
    model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, 
    contrasts = NULL, offset, ...)  {
  
    ret.x &lt;- x
    ret.y &lt;- y
    cl &lt;- match.call()
    mf &lt;- match.call(expand.dots = FALSE)
    m &lt;- match(x = c(&quot;formula&quot;, &quot;data&quot;, &quot;subset&quot;, &quot;weights&quot;, &quot;na.action&quot;, &quot;offset&quot;), 
               table = names(mf), nomatch = 0L)
    mf &lt;- mf[c(1L, m)]
    mf$drop.unused.levels &lt;- TRUE
    mf[[1L]] &lt;- quote(stats::model.frame)
    mf &lt;- eval(expr = mf, envir = parent.frame())</code></pre>
<p>The goal of this code is to manipulate the formula and other arguments into an acceptable set of arguments to the <code>model.frame</code> function in the <code>stats</code> package. The code will modify the call to <code>lm</code> to use as the substrate into <code>model.frame</code>, which has many similar arguments (e.g. <code>formula</code>, <code>data</code>, <code>subset</code>, and <code>na.action</code>). However, there are arguments that are not common to both functions.</p>
<p>The object <code>mf</code> is initially created to mirror the original call. After executing <code>match.call(expand.dots = FALSE)</code>, our original call generates a value of</p>
<pre><code>lm(formula = Sepal.Width ~ Petal.Width + log(Petal.Length) + Species, 
   data = iris, subset = Sepal.Length &gt; 4.6)</code></pre>
<p>and <code>class(mf)</code> has a value of <code>&quot;call&quot;</code>. Note that the first element of the call, <code>mf[[1L]]</code>, has a value of <code>lm</code> with the class of <code>name</code>.</p>
<p>The next few lines remove any arguments to <code>lm</code> that are not arguments to <code>model.frame</code>, and adds another (<code>drop.unused.levels</code>). Finally, the call is modified by replacing the first element of the call (<code>lm</code>) to <code>stats::model.frame</code>. Now, <code>mf</code>, has a value of</p>
<pre class="r"><code>stats::model.frame(formula = Sepal.Width ~ Petal.Width + log(Petal.Length) + Species, 
                   data = iris, 
                   subset = Sepal.Length &gt; 4.6, 
                   drop.unused.levels = TRUE)</code></pre>
</div>
<div id="creating-the-model-frame-and-terms" class="section level3">
<h3>Creating the Model Frame and Terms</h3>
<p>When this code is executed using <code>eval(expr = mf, envir = parent.frame())</code>, the <code>model.frame</code> function returns</p>
<blockquote>
<p>A <code>data.frame</code> containing the variables used in formula plus those specified in <code>...</code>. It will have additional attributes, including “<code>terms</code>” for an object of class “<code>terms</code>” derived from <code>formula</code>, and possibly “<code>na.action</code>” giving information on the handling of <code>NA</code>s (which will not be present if no special handling was done, e.g. by <code>na.pass</code>).</p>
</blockquote>
<p>For our particular call, the first six values of <code>mf</code> are</p>
<pre><code>  Sepal.Width Petal.Width log(Petal.Length) Species
1         3.5         0.2             0.336  setosa
2         3.0         0.2             0.336  setosa
3         3.2         0.2             0.262  setosa
5         3.6         0.2             0.336  setosa
6         3.9         0.4             0.531  setosa
8         3.4         0.2             0.405  setosa</code></pre>
<p>Note that :</p>
<ul>
<li>all of the columns are present, predictors <em>and</em> response,</li>
<li>the filtering defined by the <code>subset</code> command is executed here (note the row names above),</li>
<li>the <code>Petal.Length</code> has been log transformed and the column name is not a valid name, and</li>
<li>the Species variable has not generated any dummy variables.</li>
</ul>
<p>If weights or an offset was used in the model, the resulting model frame would also include these.</p>
<p>As alluded to above, <code>mf</code> has several attributes, and includes one that would not normally be associated with a data frame (e.g. <code>&quot;terms&quot;</code>). The <code>terms</code> object contains the data that defines the relationships between variables in the formulas, as well as any transformations of the individual predictors (e.g. <code>log</code>). For our original model:</p>
<pre class="r"><code>mod1$terms</code></pre>
<pre><code>## Sepal.Width ~ Petal.Width + log(Petal.Length) + Species
## attr(,&quot;variables&quot;)
## list(Sepal.Width, Petal.Width, log(Petal.Length), Species)
## attr(,&quot;factors&quot;)
##                   Petal.Width log(Petal.Length) Species
## Sepal.Width                 0                 0       0
## Petal.Width                 1                 0       0
## log(Petal.Length)           0                 1       0
## Species                     0                 0       1
## attr(,&quot;term.labels&quot;)
## [1] &quot;Petal.Width&quot;       &quot;log(Petal.Length)&quot; &quot;Species&quot;          
## attr(,&quot;order&quot;)
## [1] 1 1 1
## attr(,&quot;intercept&quot;)
## [1] 1
## attr(,&quot;response&quot;)
## [1] 1
## attr(,&quot;.Environment&quot;)
## &lt;environment: R_GlobalEnv&gt;
## attr(,&quot;predvars&quot;)
## list(Sepal.Width, Petal.Width, log(Petal.Length), Species)
## attr(,&quot;dataClasses&quot;)
##       Sepal.Width       Petal.Width log(Petal.Length)           Species 
##         &quot;numeric&quot;         &quot;numeric&quot;         &quot;numeric&quot;          &quot;factor&quot;</code></pre>
<p>The <code>terms</code> object will be used to generate design matrices on new data (e.g. samples being predicted).</p>
</div>
<div id="creating-the-design-matrix" class="section level3">
<h3>Creating the Design Matrix</h3>
<p>The <code>lm</code> code has some additional steps to save the model terms and generate the design matrix:</p>
<pre class="r"><code>mt &lt;- attr(x = mf, which = &quot;terms&quot;)
x &lt;- model.matrix(object = mt, data = mf, contrasts.arg = contrasts)</code></pre>
<p>The <code>model.matrix</code> function uses the data in the <code>terms</code> object to generate any interactions and/or dummy variables from factors. This work is mostly accomplished by a C routine.</p>
</div>
</div>
<div id="the-predictive-nature-of-the-terms" class="section level1">
<h1>The Predictive Nature of the <code>terms</code></h1>
<p>In the previous example, the log transformation is applied to one of the columns. When using an inline function inside a formula, this transformation will be applied to the current data, as well as any future data points (say, via <code>predict.lm</code>). The same workflow is followed where a model frame is used with the <code>terms</code> object and <code>model.matrix</code>.</p>
<p>However, there are some operations that can be specified in a formula that require statistical estimates. Two examples:</p>
<ul>
<li>a <a href="https://en.wikipedia.org/wiki/Spline_interpolation">natural spline</a> (<code>splines::ns</code>) takes a numeric variable, does some computations, and expands that variable into multiple features that can be used to model that predictor in a nonlinear fashion.</li>
<li>orthogonal polynomials (<code>stats::poly</code>) is a basis expansion that takes a single predictor and produces new columns that correspond to the polynomial degree.</li>
</ul>
<p>As an example of natural splines:</p>
<pre class="r"><code>library(splines)
pwidth_ns &lt;- ns(iris$Petal.Width[1:100], df = 2)
tail(pwidth_ns)</code></pre>
<pre><code>##            1       2
##  [95,] 0.539  0.1326
##  [96,] 0.563  0.0260
##  [97,] 0.539  0.1326
##  [98,] 0.539  0.1326
##  [99,] 0.577 -0.0662
## [100,] 0.539  0.1326</code></pre>
<p><code>ns</code> returns multiple elements: the basis function spline results (shown just above) and the data required to generate them for new data (in the attributes).</p>
<pre class="r"><code>attributes(pwidth_ns)</code></pre>
<pre><code>## $dim
## [1] 100   2
## 
## $dimnames
## $dimnames[[1]]
## NULL
## 
## $dimnames[[2]]
## [1] &quot;1&quot; &quot;2&quot;
## 
## 
## $degree
## [1] 3
## 
## $knots
## 50% 
## 0.8 
## 
## $Boundary.knots
## [1] 0.1 1.8
## 
## $intercept
## [1] FALSE
## 
## $class
## [1] &quot;ns&quot;     &quot;basis&quot;  &quot;matrix&quot;</code></pre>
<p>It turns out that the only statistics required to produce new spline results are the <code>knots</code>, <code>Boundary.knots</code>, and <code>intercept</code> attributes. When new data are predicted, those statistical quantities are used:</p>
<pre class="r"><code>tail(predict(pwidth_ns, iris$Petal.Width[101:150]))</code></pre>
<pre><code>##             1     2
## [45,] -0.0344 1.799
## [46,]  0.0671 1.513
## [47,]  0.2702 0.941
## [48,]  0.2194 1.084
## [49,]  0.0671 1.513
## [50,]  0.3210 0.798</code></pre>
<p>Now, getting back to formulas, we can include a function like this inline:</p>
<pre class="r"><code>mod2 &lt;- lm(Sepal.Width ~ ns(Petal.Width, df = 2) + Species, data = iris)</code></pre>
<p>The resulting <code>terms</code> object saves the model specification, and also the values required to reproduce the spline basis function. The <code>terms</code> object contains an attribute that is misleadingly named <code>predvars</code> that has this information:</p>
<pre class="r"><code>attr(x = mod2$terms, which = &quot;predvars&quot;)</code></pre>
<pre><code>## list(Sepal.Width, ns(Petal.Width, knots = 1.3, Boundary.knots = c(0.1, 
## 2.5), intercept = FALSE), Species)</code></pre>
<pre class="r"><code>## The part with `ns` is in the _third_ element:
attr(x = mod2$terms, which = &quot;predvars&quot;)[[3]]</code></pre>
<pre><code>## ns(Petal.Width, knots = 1.3, Boundary.knots = c(0.1, 2.5), intercept = FALSE)</code></pre>
<p>When <code>predict.lm</code> is invoked with a new data set, the terms are passed to <code>model.frame</code> and the <code>predvars</code> are evaluated on the new data, e.g.,</p>
<pre class="r"><code>eval(attr(x = mod2$terms, which = &quot;predvars&quot;)[[3]], envir = head(iris))</code></pre>
<pre><code>##           1       2
## [1,] 0.0635 -0.0422
## [2,] 0.0635 -0.0422
## [3,] 0.0635 -0.0422
## [4,] 0.0635 -0.0422
## [5,] 0.0635 -0.0422
## [6,] 0.1878 -0.1226
## attr(,&quot;degree&quot;)
## [1] 3
## attr(,&quot;knots&quot;)
## 50% 
## 1.3 
## attr(,&quot;Boundary.knots&quot;)
## [1] 0.1 2.5
## attr(,&quot;intercept&quot;)
## [1] FALSE
## attr(,&quot;class&quot;)
## [1] &quot;ns&quot;     &quot;basis&quot;  &quot;matrix&quot;</code></pre>
<p>In summary, R’s formula interface works by exploiting the original formula as a general expression, and the <code>terms</code> object is where most of the information about the design matrix is stored.</p>
<p>Finally, it is possible to include more complex operations in the formula. For example, two techniques for imputation in predictive models are using tree ensembles and <em>K</em>-nearest neighbors. In each case, a model can be created to impute a predictor, and this model also could be embedded into <code>predvars</code> as long as the prediction function can be exploited as an expression.</p>
<p>There are some severe limitations to formulas which may not be obvious and various packages have had to work around these issues. The second post on formulas (“The Bad”) will illustrate these shortcomings.</p>
</div>
