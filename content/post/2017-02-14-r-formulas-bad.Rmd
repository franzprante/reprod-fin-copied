---
author: "Max Kuhn"
categories: [R Language]
date: 2017-03-01
draft: false
summary: "Limitations to the model formula method are discused."
tags: [R]
title: "The R Formula Method: The Bad Parts"
---

```{r setup, include=FALSE}
# packages required for this post
for (pkg in c('randomForest', 'rpart', 'caret', 'ggplot2')) 
  if (!requireNamespace(pkg)) install.packages(pkg)
```

R's model formula infrastructure was discussed in [my previous post](https://www.rstudio.com/rviews/2017/02/01/the-r-formula-method-the-good-parts/). Despite the elegance and convenience of the formula method, there are some aspects that are limiting. 

## Limitations to Extensibility

The model formula interface does have some limitations:

* It can be kludgy with many operations on many variables (e.g., log transforming 50 variables via a formula without using `paste`)
* The `predvars` aspect (discussed in [my previous post](https://www.rstudio.com/rviews/2017/02/01/the-r-formula-method-the-good-parts/)) limits the utility of the operations. Suppose a formula had: `knn_impute(x1) + knn_impute(x2)`. Do we embed the training set twice in `predvars`?
* Operations are constrained to single columns or features (excluding interaction specifications). For example, you cannot do
```{r pca, eval = FALSE}
lm(y ~ pca(x1, x2, x3), data = dat)
## or nested functions 
lm(y ~ pca(scale(x1), scale(x2), scale(x3)), data = dat)
```

I'll use PCA feature extraction a few times here since it is probably familiar to many readers.

## Everything Happens at Once

Some of our data operations might be sequential. For example, it is not unreasonable to have predictors that require:

 1. imputation of a missing value
 2. centering and scale
 3. conversion to PCA scores


Given that the formula method operations happen (in effect) at once, this workflow requires some sort of custom solution. While [`caret::preProcess`](https://topepo.github.io/caret/pre-processing.html#pp) was designed for this sequence of operations, it does so in a single call, as opposed to a progression of steps exemplified by [`ggplot2`](https://cran.r-project.org/package=ggplot2),  [`dplyr`](https://cran.r-project.org/package=dplyr), or [`magrittr`](https://cran.r-project.org/package=magrittr).

Allowing a series of steps to be defined in order is more consistent with how data analysis is conducted. However, it does raise the complexity of the underlying implementation. For example, [`caret::preProcess`](https://topepo.github.io/caret/pre-processing.html#pp) dictates the possible sequence of tasks to be:  filters, single-variable transformations, normalizations, imputation, signal extraction, and spatial sign. This avoids nonsensical sequences that center the data before applying a Box-Cox calculation (which requires positive data).

### No Recycling

As a corollary to the point above, there is no way to recycle the `terms` between models that share the same formula and data/environment. For example, if I fit a CART model to a data set with many predictors, the random forest model (theoretically) shouldn't need to recreate the same `terms` information about the design matrix. If the model function has the non-formula interface (e.g., `mod_func(x, y)`), this can make it easier. However, many do not. 

Also, suppose that one of the pre-processing steps is computationally expensive. We'd like to be able to store the state of the results and then _add_ another layer of computations (perhaps as a separate object). 

 
### Formulas and Wide Datasets

The `terms` object saves a matrix with as many rows as formula variables and at least as many columns (depending on interactions, etc). Most of this data is zero and a non--sparse representation is used. The current framework was built in a time where there was more focus on interactions, nesting and other operations on a small scale.

It is unlikely that models would have hundreds of interaction terms, but now it is not uncommon to have hundreds or thousands of main effects. As the number of predictors increases, this takes up an inordinate amount of execution time. For simple [`randomForest`](https://cran.r-project.org/package=randomForest) or [`rpart`](https://cran.r-project.org/package=rpart) calls, the formula/`terms` work can account for most of the execution time. For example, we can calculate how much time functions spend generating the model matrix relative to the total execution time. For `rpart` and `randomForest`, we used the default arguments and did the calculations with a simulated data set of 200 data points and varying numbers of predictors:   

```{r large_p, echo = FALSE, cache = TRUE, message = FALSE, warning = FALSE}
rf_terms <- function(formula, data = NULL, ..., subset, na.action = na.fail)  {
  if (!inherits(formula, "formula")) 
    stop("method is only for formula objects")
  m <- match.call(expand.dots = FALSE)
  if (any(c("xtest", "ytest") %in% names(m))) 
    stop("xtest/ytest not supported through the formula interface")
  names(m)[2] <- "formula"
  if (is.matrix(eval(m$data, parent.frame()))) 
    m$data <- as.data.frame(data)
  m$... <- NULL
  m$na.action <- na.action
  m[[1]] <- as.name("model.frame")
  m <- eval(m, parent.frame())
  y <- model.response(m)
  Terms <- attr(m, "terms")
  attr(Terms, "intercept") <- 0
  attr(y, "na.action") <- attr(m, "na.action")
  m <- model.frame(terms(reformulate(attributes(Terms)$term.labels)), 
                   data.frame(m))
  for (i in seq(along = m)) {
    if (is.ordered(m[[i]])) 
      m[[i]] <- as.numeric(m[[i]])
  }
}

rp_terms <- function(formula, data, weights, subset, na.action = na.rpart, 
                        method, model = FALSE, x = FALSE, y = TRUE, parms, control, 
                        cost, ...) 
{
  Call <- match.call()
  if (is.data.frame(model)) {
    m <- model
    model <- FALSE
  }
  else {
    indx <- match(c("formula", "data", "weights", "subset"), 
                  names(Call), nomatch = 0L)
    if (indx[1] == 0L) 
      stop("a 'formula' argument is required")
    temp <- Call[c(1L, indx)]
    temp$na.action <- na.action
    temp[[1L]] <- quote(stats::model.frame)
    m <- eval.parent(temp)
  }
  Terms <- attr(m, "terms")
  if (any(attr(Terms, "order") > 1L)) 
    stop("Trees cannot handle interaction terms")
  Y <- model.response(m)
  wt <- model.weights(m)
  if (any(wt < 0)) 
    stop("negative weights not allowed")
  if (!length(wt)) 
    wt <- rep(1, nrow(m))
  offset <- model.offset(m)
  X <- rpart:::rpart.matrix(m)
 
}

n <- 200
p <- floor(10^seq(log10(15), 4, length = 10))
rf_pct <- data.frame(variables = p, percentage = NA,
                     baseline = NA, full = NA,
                     func = "randomForest",
                     ones = NA)
rp_pct <- rf_pct
rp_pct$func <- "rpart"

library(caret)
library(rpart)
library(randomForest)
for (i in seq(along = p)) {
  set.seed(1 + i)
  dat <- twoClassSim(n, noiseVars = p[i])
  
  rf_pct$baseline[i] <- system.time(rf_terms(Class ~ ., data = dat))[3]
  rf_pct$full[i]     <- system.time(randomForest(Class ~ ., data = dat))[3]
  rp_pct$baseline[i] <- system.time(rp_terms(Class ~ ., data = dat))[3]
  rp_pct$full[i]     <- system.time(rpart(Class ~ ., data = dat))[3]
  
  tmp_mod <- rpart(Class ~ ., data = dat)
  tmp_fact <- attr(tmp_mod$terms, "factors")
  rp_pct$ones[i] <- sum(tmp_fact != 0)/prod(dim(tmp_fact))
}

percents <- rbind(rf_pct, rp_pct)
percents$percentage <- percents$baseline/percents$full*100

theme_set(theme_bw())
ggplot(percents, aes(x = variables, y = percentage, color = func)) + 
  geom_point() + scale_x_log10() + geom_line() +
  xlab("# Predictors") + 
  ylab("% Execution Time for Formula Computations") +
  theme(legend.position = "top")
```

This is especially problematic for ensemble models. For example, `ipred:::ipredbagg` creates an ensemble of `rpart` trees. Since `rpart` only has a formula method, the footprint of the bagged model object can become very large if _X_ trees are contained in the ensemble.  Alternatively, `randomForest.formula` takes the approach of generating the `terms` once and feeding the model frame to `randomForest.default`. This does not work for `rpart` since there is no non-formula method exposed. Some functions (e.g., `lm`, `survival::coxph`) have arguments that can be used to prevent the `terms` and similar objects from being returned. This saves space but prevents new samples from being predicted. A little more detail can be found [here](https://developer.r-project.org/model-fitting-functions.html). 

One issue is the `"factors"` attribute of the `terms` object (discussed in the previous post). This is a non-sparse matrix that has a row for each predictor in the formula and a column for each model term (e.g. main effects, interactions, etc.). The purpose of this object is to know which predictors are involved in which terms. 

The issue is that this matrix can get very large and usually has a high proportion of zeros. For example:
```{r factors}
mod3 <- lm(Sepal.Width ~ Petal.Width + Petal.Length*Species, data = iris)
fact_mat <- attr(mod3$terms, "factors")
fact_mat
```
As the number of predictors increases, the rate of ones is likely to approach a value close to zero very quickly. For example:

```{r sparse, echo = FALSE, cache = TRUE, message = FALSE, warning = FALSE}
theme_set(theme_bw())
ggplot(rp_pct, aes(x = variables, y = ones)) + 
  geom_point() + geom_line() + 
  scale_x_log10() + scale_y_log10() + 
  xlab("# Predictors") + ylab("Proportion of Non-Zeros Factor Entries")
```

Again, it is doubtful that a model with a large number of predictors will have a correspondingly large number of high-level interactions (see the [Pareto principle applied to modeling](https://en.wikipedia.org/wiki/Sparsity-of-effects_principle)).
 

### Variable Roles

Some packages have implemented extensions of the basic formula. There are cases when formula are needed for specific sub-models. For example, a random coefficient model can be fit with the `lmer` function. In this case, a model is specified for a particular clustering variable (e.g., a subject in a clinical trial). The code is an example of how `lmer` syntax works:
```{r lmer, eval = FALSE}
# ?lme4::lmer
lmer(Reaction ~ Days + (Days | Subject), data = sleepstudy)
````
Here `Subject` is important to the model-fitting routine, but not as a predictor. Similarly, the [Bradley-Terry model](https://www.jstatsoft.org/article/view/v012i01/v12i01.pdf) can be used to model competitions and contests. A model on a set of boxers in a series of contests can include terms for their reach:
```{r bt, eval = FALSE}
BTm(outcome = 1, player1 = winner, player2 = loser, 
    formula = ~reach[..] + (1 | ..), 
    data = boxers)
```
Another extension of basic formulas comes from the [`modeltools`](https://cran.r-project.org/package=modeltools) and [`mboost`](https://cran.r-project.org/package=mboost) packages. The function `mboost::mob` fits a tree-based model with regression models in the terminal nodes. For this model, a separate list of predictors are used as _splitting_ variables (to define the tree structure) and another set of _regression_ variables that are modeled in the terminal nodes. An example of this call is: 
```{r mob, eval = FALSE}
# mboost::mob (using the modeltools package for formulas)
mob(diabetes ~ glucose | pregnant + mass +  age,
    data = PimaIndiansDiabetes)
```
The commonality between these three examples is that there are variables that are critical to the model but do not play the role of standard regression terms. For `lmer`, `Subject` is the independent experimental unit. For `mob`, we have variables to be used for splitting, etc. 

There are similar issues on the left-hand side of the formula. When there are multivariate outcomes, different packages have different approaches: 
```{r mutivariate, eval = FALSE}
# ?aggregate the mean of two variables by month
aggregate(cbind(Ozone, Temp) ~ Month, data = airquality, mean)

# grouped binomial data:
glm(cbind(events, nonevents) ~ x, family = binomial)

# pls::plsr, 
pls(sensory ~ chemical, data = oliveoil)
# sensory and chemical are 2D arrays in the oliveoil data frame
``` 

The overall point here is that, for the most part, the formula method assumes that there is one variable on the left-hand side of the tilde and that the variables on the right-hand side are predictors (exceptions are discussed below). One can envision other roles that columns could play in the analysis of data. Besides the examples given above, variables could be used for  

 * outcomes
 * predictors
 * stratification 
 * data for assessing model performance (e.g., loan amount to compute expected loss)
 * conditioning or faceting variables (e.g., [`lattice`](https://cran.r-project.org/package=lattice) or  [`ggplot2`](https://cran.r-project.org/package=ggplot2))
 * random effects or hierarchical model ID variables
 * case weights
 * offsets
 * error terms (limited to `Error` in the `aov` function)

The last three items on this list are currently handled in formulas as "specials" or have existing functions. For example, when the model function has a `weights` argument, the current formula/`terms` frame work uses a function (`model.weights`) to extract the weights, and also makes sure that the weights are not included as covariates. The same is true for offsets. 

 
## Summary

Some limitations of the current formula interface can be mitigated by writing your own or utilizing the   [`Formula`](https://cran.r-project.org/package=Formula) package. 

However, there are a number of conceptual aspects (e.g., roles, sequential processing) that would require a completely different approach to defining a design matrix, and this will be the focus of an upcoming tidyverse package. 
 
